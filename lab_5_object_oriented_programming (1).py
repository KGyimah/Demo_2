# -*- coding: utf-8 -*-
"""Lab_5_Object Oriented Programming.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/19SAyY3PR0dLoSWKk0xn3F-sZhi-JlPd6

# Object Oriented Programming(OOP)

Object-oriented programming (OOP) is a computer programming model that is based on the concept of classes and objects, rather than functions and logic. 

Whilst procedural programming is about writing procedures or functions that perform operations on the data,object-oriented programming is about creating **classes and objects that contain both data and functions**.

A class is an abstract blueprint used to create more specific, concrete objects. 
A class defines what attributes an instance of this type will have, like color, but not the value of those attributes for a specific object.

Classes can also contain functions, called methods available only to objects of that type.

Methods are defined within the class and perform some action by a specific object or class.
An object can have attributes and behavior.
 


Advantages of OOP
1. OOP is faster and easier to execute
2. OOP provides a clear structure for the programs
3. OOP helps to keep code DRY "Don't Repeat Yourself", and makes the code easier to maintain, modify and debug
4. OOP makes it possible to create full reusable applications with less code and shorter development time

Take note of the following:
1. class
2. object
3. instance
4. methods
5. inheritance


### Consider the this example
                                  
                                  
                                  
                                  Human    -------> class
                                  
                                  Dominic  -------> object
                                  
                                  Height,color,weight, hands,head,address --------> Attributes
                                  
                                  write,run,type fast,code,read,analyze   --------> methods
   
From the example above, it can be inferred that,

a class is a blue print

an object is a data field that manifest the blue print

an attribute is a property of an object

a method is any action that is done by an object or a class.

Methods are functions defined within a class.
"""



"""# Demonstration

## class Anatomy

#### Creating a class

A class in python is created with the keyword class.

The body of a class contain attributes and methods.

A class have a head and body.

Unlike functions and methods, a class name begins with capital letter. 

Let's dive deep into classes through the demonstrations below.
"""

class Student: #-------> head
                                           #This an empty class
    pass #------> body

"""####  Objects  of a class"""

s1 = Student()

s2 = Student()  # s1 and s2 are objects of the empty class Student

type(s1)

"""#### Methods and Attributes"""

def identity(self,name):
    print("I am"+" "+ name) # This a method
                            # A method is similar to function except the special self argument which we later talk about.

idntity('John')

# A class with a method
class Student:
    
    def identity(self,name):
        print("I am"+" "+ name, ","+" a Data Science student at Blossom Academy")

Dominic = Student()

Jessica = Student()

s1 = Student()
s2 = Student()

Dominic.identity("Dominic")

Jessica.identity('Jessica')

s2.identity('Ola')



class Pet:
    def num_leg(self,number_legs):
        print('It has'+' '+ number_legs+' '+'legs')

pusy = Pet()

snow_bird = Pet()

pusy.num_leg('4')





"""### Note
Calling a method from an object is the same as passing the object as an argument to a method from the class.

Check the examples below:
"""

Student.identity(Jessica,"Jesicca") # This is the same as Jessica.identity()

Student.identity(s2,"Ola") # This is the same as s2.identity()

"""# Encapsulation
By the principle of OOP, the data and the methods that operate on the data must be together.

This is achieved through encasulation.

**Encapsulation** in this regard, is the act of binding data with the methods that operate on the data.


Check the examples below:

#### Defining an attribute throuhg a method either than the \_\_init\_\_ method
"""

class Student:
    def give_id(self,ID):
        self.ID = ID
        
    def give_name(self,name):
        self.name = name
        
        
    def identity(self,name):
        print("I am"+" "+ name, ","+" a Data Science student at Blossom Academy")

# Note that the attribute and the method are bundles under one class.

Dominic = Student()

Dominic.ID

Dominic.give_id(1091442)

Dominic.ID

Dominic.name

Dominic.give_name('Dominic')

Dominic.name

"""###  \_\_init\_\_ method and self argument

The \_\_init\_\_ method serves as a constructor.
Pyhton automatically call the \_\_init\_\_ method when ever an object is created hence creates attributes for that object. 

The self argument is a special argument which serves as a holder of the other arguments.

It allows you to access other arguments and call methods from within a class definition.

It also stand -in for a particular object used in the class definition

Every method should contain a self argument.

Any other word can be used inplace of the self but it a convention to use the word self.

"""

# Defining attributes through init method.

class Student:
    def __init__(self,name,course,year):
        self.name = name      # name, course and year are attributes
        self.course = course
        self.year = year
        
    def identity(self): # This a method
        print("I am"+" "+ self.name, ","+" a "+ self.course +" "+"student at Blossom Academy")

"""### Instantiating objects of a class

"""

s1 = Student("Kelden","Data Science",2021)
s2 = Student("Jessie","Python programming",2020)
s3 = Student("Aurelia","Web design",2021)
s4= Student("Dominic","Business Intelligence with Tableau",2019)
s5 = Student("Jessica","Cyber Security",2021)

s1.name

s1.name,s1.course

[s1.name,s1.course]

s4.name,s4.course, s4.year

s4.identity()

Student.identity(s4)



#example 1.
#creating a class

class Shirt: #Shirt ----> Class name. It always starts with a capital letter
    def __init__(self,category,colour,size,price): # the __init__ serves as a constructor
                                                   # the self argument is a special argument
                                                   # which serves as a holder of the other arguments,
                                                   # the self argument allows the other arguments to be 
                                                    #referenced in the class
                                                   # It also stand- in for a particular object used in 
                                                    #the class definition
                                                   # category,colour,size,price are attributes  
        
        self.category = category
        self.colour = colour
        self.size = size
        self.price = price
        
        #methods
    def change_price(self,new_price):                #change_price, change_price, dC,sales are methods
        self.price = new_price
        
    def discount_price(self,discount):
        return self.price*(1-discount)
    
    def sales(self,quantity):
        return self.price*quantity

"""### Creating or instantiating an object """

shirt_1 = Shirt('T-shirt','blue',28,10)

shirt_2 = Shirt('Long-sleeve','white',30,100)

shirt_3 = Shirt('Short-sleeve','multi-coloured',25,30)

shirt_1.colour

shirt_1.price

shirt_1.change_price(15)

shirt_1.price

shirt_1.discount_price(0.05)

shirt_2.category

shirt_1.price

shirt_1.change_price(30)

shirt_1.price



shirt_1.sales(135)

shirt_1.discount_price(0.05)



shirt_3.price

shirt_3.change_price(50)

shirt_3.price

shirt_3.sales(30)

Shirt.sales(shirt_3,30)

Shirt.sales(shirt_1,200)

shirt_1.category

shirt_2.sales(12)

shirt_3.sales(10)

# you can call a method through the main class.
Shirt.sales(shirt_3,10)

# the computational methods below give the same results.
print(shirt_2.discount_price(0.03))

print(Shirt.discount_price(shirt_2,0.03))

shirt_3.colour

# Example 2
    
class Employee: # Employee -----> Class name
 
    
        def __init__(self,first,last,pay):
            self.first = first
            self.last = last
            self.pay = pay
            self.email = first.lower()+last.lower()+'@company.com'
    
            # method
        def fullname(self):
            return '{} {}'.format(self.first,self.last)

# Insatantiating objects


emp_1 = Employee('Joe','Louis',9500)
emp_2 = Employee('John' ,'Bruce',6500)

# calling a method of an object from the object

emp_1.fullname()

emp_2.fullname()

# calling a method of an object from the class
Employee.fullname(emp_1)

emp_1.email

Employee.fullname(emp_2)

emp_2.email

print(emp_2.pay)
print(emp_1.pay)

"""### Some best practices

1. Initialize attributes in \_\_init\_\_ method
2. Start class names with capital letters and avoid using python reserved words as class names
3. Keep using self
4. Add doctrings to classes when necessary
"""





"""# Instance level data and class level data

**Instance level data** refers to data that is attached to objects(instances)through the self argument and can only be acessed by the objects but not tha class itself.

**class level data** refers to data that can be accessed by all objects of a class and the class itself.
In creating a class level data eg: say class variable, one does not need to employ the self argument.


Instance level data may include intance attributes and instance methods whilst  class level data may include class attributes and class methods.

check the example following demonstartions:

### Demo 1 (class variables and instance variables)
"""

class Region:
    
    national_capital = 'Accra' # This is class variable or class argument and accessed by
                                # both the class and the instance
    
    def __init__(self,name,capital,language,farm_produce,size,population):        
        #All the arguments within the init function are instance arguments(variables)
        #and can only be accessed by the instants.
        self.name = name
        self.capital = capital
        self.language = language
        self.farm_produce = farm_produce
        self.size = size
        self.population = population

    def density(self): #This is an instance method
            return round(self.size/self.population,5)

Greater_Accra =Region('Greater Accra','Accra','Ga','Fish',3245,13000000)
Ashanti_region =Region('Ashanti Region','Kumasi','Akan','Maize',24829,10000000)
Eastern_region =Region('Eastern_region','Koforidua','Akan','Cocoa',19323,8000000)
Western_region =Region('Western_region','Takoradi','Akan','Cocoa',23941,8670000)
Northern_Region =Region('Northern_Region','Tamale','Dagbani','Yam',70765,7000000)
Volta_region =Region('Volta_region','Ho','Ewe','Cabbage',20570,6050000)
Upper_East_region =Region('Upper_East_region','Bolga Tanga','Kusal','Onion',24829,3000000)

Volta_region.capital

Volta_region.national_capital

Ashanti_region.national_capital

Region.national_capital

Region.capital

Upper_East_region.capital

print(Greater_Accra.name)
print(Greater_Accra.density())
print(Ashanti_region.density())
print(Region.national_capital)
print(Ashanti_region.national_capital)

"""### Demo 2 (Instance methods and class methods)

##### Note:
Class method has a @classmethod decorator that identifies it as a class method.

class methods have use cls inplaceof self.
class methods can be accessed by all instances.
class methods can't use instance-level data.

To call a class method use the class.method syntax rather  than using the object.method syntax 

"""

class Region:
    country = "Ghana"
    national_capital = 'Accra' # This is class variable or class argument
    length = 5000
    breath = 3000
    
    def __init__(self,name,capital,language,farm_produce,size,population):        
        #All the arguments within the init function are instance arguments(variables)
        #and can only be accessed by the instants.
        self.name = name
        self.capital = capital
        self.language = language
        self.farm_produce = farm_produce
        self.size = size
        self.population = population

    #Instance method    
    def density(self):        
            return round(self.size/self.population,5)
        
    @classmethod 
    def anthem(cls,country):      #This is a class method
        print("God bless our homeland {},\nAnd make our nation great and strong\nlaala lala lalalaala....".format(country))

Region.anthem("Ghana")

Region.density()

Greater_Accra =Region('Greater Accra','Accra','Ga','Fish',32445565,13000000)

Greater_Accra.anthem("Ghana")

Greater_Accra.density()

"""### Inheritance

Inheritance is the act of allowing a class to possess all the properties (attributes and methods) of another class. 

The class which is being inherited is called **parent class** whilst the one that inherits is called **child class**

 #### Advantages
 
1. It allows code reusability: That is to say that we do not have to write a code repeatedly.We can just inherit the properties we need from a another class which then becomes a parent class.

   

2. Inheritance is transitive in nature.This is to say that if a child class inherits properties from a parent class, then all other sub-classes of the child class will also inherit the properties of the parent class.

### Demo
"""

#Demo 1
class Employee:
    MIN_SALARY = 30000    

    def __init__(self, name, salary=MIN_SALARY):
        self.name = name
        if salary >= Employee.MIN_SALARY:
            self.salary = salary
        else:
            self.salary = Employee.MIN_SALARY
        
    def increase(self, amount):
        self.salary += amount      
        
        
        
        
        
#Manager class inheriting from Employee class
class Manager(Employee):
    pass

mng = Manager('John Bossco',450000)

mng.name

mng.salary

mng.increase(1000)

mng.salary

isinstance(mng,Manager)

isinstance(mng ,Employee)

issubclass(Manager,Employee)

issubclass(Employee,Manager)



class Employee:
    MIN_SALARY = 30000    

    def __init__(self, name, salary=MIN_SALARY):
        self.name = name
        if salary >= Employee.MIN_SALARY:
            self.salary = salary
        else:
            self.salary = Employee.MIN_SALARY
        
    def increase(self, amount):
        self.salary += amount      
        
#Manager class inheriting from Employee class
class Manager(Employee):
    def add_title(self):
        print("Manager"+" "+self.name)

mng = Manager('John Bossco',450000)

mng.add_title()

manaseh = Employee('Manaseh',70000)

manaseh.increase(3000)

manaseh.salary

manaseh.add_title()

"""### Customizing functionality through inheritance """

# cutomizing constructors

class Employee:
    def __init__(self, name, salary=30000):
        self.name = name
        self.salary = salary

    def increase(self, amount):
        self.salary += amount

        
class Manager(Employee):
  # Add a constructor 
    def __init__(self, name, salary = 50000, project = None):

        # Call the parent's constructor   
        Employee.__init__(self,name, salary)

        # Assign project attribute
        self.project = project

  
    def give_title(self):
        print("Manager ", self.name)

mng = Manager("OLa",120000,4000)

mng.project



# Customizing a method in a child class

class Employee:
    def __init__(self, name, salary=30000):
        self.name = name
        self.salary = salary

    def increase(self, amount):
        self.salary += amount

        
class Manager(Employee):
    def give_title(self):
        print("Manager ", self.name)

    def __init__(self, name, salary=50000, project=None):
        Employee.__init__(self, name, salary)
        self.project = project

    # Add an increase method
    def increase(self, amount, bonus=1.05):
        new_amount = amount * bonus
        Employee.increase(self, new_amount)

mngr = Manager("James Wintuma", 78500)
mngr.increase(1000)
print(mngr.salary)

mngr.increase(2000, bonus=1.03)

mngr.increase(1000)

mngr.salary

"""### Exceptions

Exception refers to the occurence where a code or script is interrupted when it encounters a situation that it cannot cope with. 

Note: When a Python script raises an exception, it must either handle the exception immediately otherwise it terminates and quits

Exceptions can be in-built or user built



Run the codes below and view the exceptions
"""

1/0

2+'Hi'

x=[1,2,3,4]
x[5]

x+y

"""### Handling exceptions

Exceptions in python can be handled using **try - except - finally block**.

**Format**

try:
    #running this code
except ExceptionName:
    # run this code if ExceptionName happens
    
#Note: You can have many exceptions
#You can add a finally block to it.

"""

try:
    x=[1,2,3,4]
    x[3]
    x[7]
except IndexError: 
    print('Sorry!!! The index is out of range')

try:
    1/0
except ZeroDivisionError:
    print('Enter a non-value')

"""### Custom Exception
* it inherits from the built in Excetion class
* it's usually an empty class
"""

def inverse(x, ind):
    try:
        return 1/x[ind]
    except ZeroDivisionError:
        print("Cannot divide by zero!")
    except IndexError:
        print("Index out of range!")

def inverse(x, ind):
    try:
        return 1/x[ind]
    except ZeroDivisionError:
        print("Cannot divide by zero!")
    except IndexError:
        print("Index out of range!")

a = [5,6,0,7]

inverse(a, 6)

a[6]

1/a[0]

inverse(a, 2)

inverse(a, 10)



"""### Raising exceptions
One can also raise an exception using the raise keyword

**format**

raise ExceptionName('Error message here')
"""

class SalaryError(ValueError): pass

class Employee:
    MIN_SALARY = 30000
    MAX_RAISE = 5000

    def __init__(self, name, salary = 30000):
        self.name = name
        # If salary is too low
        if salary < Employee.MIN_SALARY:
            # Raise a SalaryError exception
            raise SalaryError("Salary is too low!")
        self.salary = salary

emp1 = Employee('Joel',7000)

emp2 = Employee('Nancy',45000)



"""### Modules and packages in python programming

* Working directory
* File path (using the os module)
* Modules
* packages

"""

pwd

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import os

x = [12,3,4,456,67,8,9,9,8,43,231,38]

x = np.array(x)

x.mean()

np.mean(x)

np.var(x)

x = pd.Series(x)
x.plot()
plt.show()

os.mkdir('Suleman')

pwd

\n '\'

"C:\Users\JETHRO\Desktop\Bloss Docs"

os.getcwd()

x = [1,346,4,5,34,7,5,6]

np.mean(x)

def ave(x):
    return sum(x)/len(x)

ave(x)

np.mean(x)

np.sqrt(16)

#Account class

class Account:
    def __init__(self,name,balance):
        self.name = name
        self.balance = balance
    def withdraw(self,amount):
        balance = self.balance-amount
        self.balance = balance
        return balance

mary = Account('Mary',50000)

mary.balance

mary.name

mary.withdraw(10000)

mary.balance

mary.withdraw(500)

mary.balance

#Savings_account
class Savings_account(Account):
    def __init__(self,name,balance):
        Account.__init__(self,name,balance)
    def deposit(self,amount):
        bal = self.balance+amount
        self.balance = bal
        return bal

acc2 = Savings_account('Juliet',61200)

acc2.balance

acc2.deposit(1000)

acc2.balance

acc2.balance

#Check_account
class Check_account(Account):
    def __init__(self,name,balance):
        Account.__init__(self,name,balance)
    def withdraw(self,amount,fee=10):
        new_amount = amount+fee
        Account.withdraw(self, new_amount)

acc3 = Check_account('John',100000)

acc3.withdraw(1000)

acc3.balance

!pip install numpy

