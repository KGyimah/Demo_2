# -*- coding: utf-8 -*-
"""Lab_4_Functions.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/17zB6mTCEVOiJ6PG8mOi1l-MdjKDEnLI1

# What you will learn in this lesson

1. Defining functions

2. Variable scope

3. Documentation

4. Lamda expressions

5. high level functions

6. List comprehentions

# Funtions

A function is a block of codes that performs an action.

### Parts(components) of a function in python
* Function Header

The function header always starts with the def keyword, which indicates that this is a function definition.

Then comes the function name (cylinder_volume)

Immediately after the name are parentheses that may include arguments separated by commas which in our case are height and radius

Arguments, or parameters, are values that are passed in as inputs when the function is called, and are used in the function body. 

NB: If a function doesn't take arguments, these parentheses are left empty.

The header always end with a colon :.


* Funtion Body

The body of a function is the rest of the code after the header line.

Within this body, we can refer to the argument variables and define new variables, which can only be used within these indented lines.

The body will often include a return statement, which is used to send back an output value from the function to the statement that called the function.

NB: The body of a function may not contain a return stamentment but a print statement.

A return statement consists of the return keyword followed by an expression that is evaluated to get the output value for the function. 

If there is no return statement, the function simply returns None.
"""

x =[12,45,2,3,4,5,6]

min(x)

max(x)

def empty_function(): # Empty function
    
    
    
    pass

empty_function()

# Example 1
def cylinder_volume(height,radius):#<----- function header
   
    pi = 3.14186
    return height*pi*radius**2     #<------ function body

pi

cylinder_volume(3,1.2)

# height = 13
# radius = 7

cylinder_volume(13,7)



"""### Variable scope
This refers to which part of a program that a variable can be referenced or used from.

**Local variables**: they are variables that can only be accessed inside the funtion

**Global variables**: they are variables that can be accessed ouside a function.    

The **pi** in the cylinder volume function is a local variable.
"""

#pi # this variable has a local scope hence, cannot accessed outside the function

pi_ = 22/7

pi_ # Global scope

# Example 2

def area_circle(radius):
    

    
    return pi_*radius**2

area_circle(8)

#Example 3
def bmi(height,weight):
    return weight/height**2

bmi(1.6,56)

bmi(1.9,69.78)



"""### Difference between print and return in a function"""

def print_new_age(current_age,year):
    age = current_age +(year-2021)
    print(age)
    
    
def return_new_age(current_age,year):
    age = current_age +(year-2021)
    return age

print_new_age(20,2087)

return_new_age(20,2087)

x = print_new_age(20,2087)

print(x)

x

x/2 # This will produce an error

y = return_new_age(20,2087)

print(y)

y/2



def average_score(x):
    ave = sum(x)/len(x)
    return ave

def average_score_print(x):
    ave = sum(x)/len(x)
    print(ave)

marks = [477,15,4597,45698,41,2.558,7849]

average_marks = average_score(marks)

print(average_marks)

marks = [477,15,4597,45698,41,2.558,7849]

average_marks_2 = average_score_print(marks)

print(average_marks_2)

"""### arguments of a function

They are values passed as inputs to a function
"""

# default arguments

def cylinder_volume(height,radius,pi = 3.14186):
   
    return height*pi*radius**2

cylinder_volume(5,1.4)

# default arguments

def cylinder_volume(height,pi= 3.14186,radius): # This is wrong,non-default argument shouldn't follow default argument 
   
    return height*pi*radius**2

cylinder_volume(23,4,22/7)

cylinder_volume(23,4)

cylinder_volume(4,23,22/7)

"""### passing arguments
1. By position
2. By name
"""

def bmi(height,weight):
    return weight/height**2

"""### By position
To call a function by position, the arrangement of the arguments matters
"""

bmi(1.76,65) # Calling a function by position

bmi(65,1.76) # This is wrong

"""### By name
To call a function by name, the arrangement of the arguments does not matters
"""

bmi(height=1.76, weight=65) # calling a function by name

bmi(weight=65,height=1.76 )

"""## Documentation Strings (Docstrings)"""

def return_new_age(current_age,year):
    """
    Calculates the age of a person at a given year from 2021.
    
    INPUT:
    current_age: int, current age of the person.
    year: int, prefered year
    
    OUTPUT: 
    return_new_age: current_age +(year-2021), returns age of the person at the given year from 2021
    
    """
    age = current_age +(year-2021)
    return age

return_new_age(20,2087)

help(return_new_age)

def bmi(height,weight):
    """
    This function calculates the bmi of a person
    
    INPUT:
    height:float or int,height of a person in meters
    weight: float or int,weight of a person in kilograms
    """
    return weight/height**2

bmi(1.7,59)

help(bmi)

return_new_age() # put the curser inside the bracket and press shift+tab to view the docstring

?return_new_age

help(print)

?print

"""## Lamda expressions (Anonymous functions)

#### Components of a Lambda Function

The lambda keyword is used to indicate that this is a lambda expression.

Following lambda are one or more arguments for the anonymous function separated by commas, followed by a colon :. Similar to functions, the way the arguments are named in a lambda expression is arbitrary.

Last is an expression that is evaluated and returned in this function. This is a lot like an expression you might see as a return statement in a function.

With this structure, lambda expressions arenâ€™t ideal for complex functions, but can be very useful for short, simple functions.

Lamda expressions are used to create anonimous functions(functions that do not have names)
"""

def square(x):
    return x**2

square(6)

lambda x: x**2

lambda price,quantity,cost:(price*quantity)-cost

n = [12,4,5,6,3,4,67,8,9]

square_lambda = lambda x: x**2

square_lambda(6)

lambda_bmi=lambda height,weight : weight/height**2

lambda_bmi(1.7,64)

lambda_bmi(weight=64,height=1.7) # you call lambda expressions explicitly (thus names)

square=lambda argument: argument**2

square(6)

BMI=lambda w,h: w/h**2

BMI(62,1.5)

"""### some important higher-order built-in functions

1. map()

**map()** is a higher-order built-in function that takes a 

function and iterable as inputs, and returns an iterator that 

applies the function to each element of the iterable.



2.**filter()** is a higher-order built-in function that takes a 

function and iterable as inputs and returns an iterator with 

the elements from the iterable for which the function returns 

True.

### map()
"""



numbers = [ [34, 63, 88, 71, 29],[90, 78, 51, 27, 45], [63, 37, 85, 46, 22], [51, 22, 34, 11, 18]]





# using the for loop
# solution 1
for i in range(len(numbers)):
    
    print(sum(numbers[i])/len(numbers[i]))



for i in numbers:
    print(i)

# using the for loop
# solution 2
for i in numbers:
    print(sum(i)/len(i))



# Solution 3

for i,marks in enumerate(numbers):
    print(sum(numbers[i])/len(numbers[i]))



def average_score(x):
    return sum(x) / len(x)

numbers[0]

average_score(numbers[0])

map(average_score,numbers)

list(map(average_score,numbers))

map(min,numbers)

list(map(min,numbers))

list(map(max,numbers))

tuple(map(max,numbers))

set(map(max,numbers))

"""### Using lambda functions with map()"""

n = [12,4,5,6,3,4,67,8,9]

list(map(lambda x:x**2,n))

y = list(map(lambda x:x**2,n))

y





team_points=[87,45,67,90,100,12,35,89,55,55]

def add_8(value_list):
    return value_list+8

team_points_8 = list(map(add_8,team_points))
team_points_8



mean_l = lambda nums:sum(nums)/len(nums)

ave = list(map(mean_l,numbers))
print(ave)

ave = list(map(lambda nums:sum(nums)/len(nums),numbers))
print(ave)

"""### filter()"""

cities = ["New York City", "Los Angeles", "Chicago", "Mountain View", "Denver", "Boston"]

def is_short(name):
    return len(name) <10

is_short(cities[0])

is_short(cities[2])

short_cities = list(filter(is_short, cities))
print(short_cities)

is_less = lambda name: len(name) < 10
less_cities = list(filter(is_less,cities))
print(less_cities)

"""## Zip and Enumerate

## zip()

**zip** and **enumerate** are useful built-in functions that can come in handy when dealing with loops.
They help to simplify tasks.

**zip** returns an iterator that combines multiple iterables into one sequence of tuples. Each tuple contains the elements in that position from all the iterables.

### zip()
"""

country = ['Ghana','Togo','Nigeria','Ivory Coast','South Africa']

capital = ['Accra', 'Lome', 'Abuja','Abidjan','Johannesburg']

currency = ['Cedis','CFA','Naira','CFA','Rand']

#(1,'a'),(2,'b') (3,'c')

zip(country,capital,currency)

list(zip(country,capital,currency))

#example
list(zip(['a', 'b', 'c'], [1, 2, 3]))

l = ('a','e','r','t')
n =(3,4,5,6,)

list(zip(l,n))



"""### Using the for loop with zip"""

countries = ['Ghana','Togo','Nigeria','Ivory Coast','South Africa']

capitals = ['Accra', 'Lome', 'Abuja','Abidjan','Johannesburg']

currencies = ['Cedis','CFA','Naira','CFA','Rand']

for country,capital,currency in zip(countries,capitals,currencies):
    print("{} : {} : {} ".format(country,capital,currency))



"""### Unzipping"""

my_list = [('a', 1), ('b', 2), ('c', 3)]

letters, nums = zip(*my_list)              # To unzip a data structure bring a * before the input.

letters

nums

"""### Enumerate()

**enumerate** is a built in function that returns an iterator 

of tuples containing indices and values of a list.

You'll often use enumerate when you want the index along with each 

element of an iterable in a loop.
"""

letters = ['a', 'b', 'c', 'd', 'e']
list(enumerate(letters))

tuple_1 = (67,65,90,87) # tuple unpacking
x,y,z,s = tuple_1

print(x)
print(y)
print(z)
print(s)

letters = ['a', 'b', 'c', 'd', 'e']
for i, letter in enumerate(letters):
    print(i, letter)

"""### List Comprehentions

List comprehensions allow us to create a list using a for loop in one step.

You create a list comprehension with brackets [ ], including an expression to evaluate for each element in an iterable.

"""

# List comprehension format: 
# [expression followed by iterable or iteration]
#Eg:


squares = [x**2 for x in range(1,10)]
print(squares)

squares = []
for i in range(1,10):
    squares.append(i**2)
print(squares)

"""### Conditionals in List Comprehensions

You can also add conditionals to list comprehensions (listcomps).

After the iterable, you can use the if keyword to check a condition in each iteration.

"""

# Conditional list comprehension without 'else' format: 
# [exprssion followed by iterable followed by condition]
# Eg:
squares = [x**2 for x in range(1,10) if x % 2 == 0]
print(squares)

"""Conditional List Comprehensions that includes 'else' in the

condition have a different format.

In cases like this you have to move the conditionals to the beginning of

the listcomp, right after the expression.

"""

# Conditional list comprehension without 'else' format: 
# [exprssion followed by condition followed by else condition followed by iterable]
# Eg:
squares = [x**2 if x % 2 == 0 else x + 3 for x in range(1,10)]
print(squares)







"""## Exercise

### Question 1

Use a list comprehension to create a new  list called first_names containing just the first names in the list names in lowercase.
"""

names = ['Ama Frimpong','Agyemang Duah','Kwesi Amstrong','Patrick Mensah', 'Emmanuel Doe', 'Nelson Tettey']

names[0].split()[0].lower()



#Solution

first_names = [name.split()[0].lower() for name in names]
print(first_names)

names = ['Ama Frimpong','Agyemang Duah','Kwesi Amstrong','Patrick Mensah', 'Emmanuel Doe', 'Nelson Tettey']

names

for name in names:
    print(name.split()[0].lower())



"""### Question 2
Use a list comprehension to create a list called multiples_3, containing the first 20 multiples of 3.
"""

# solution
multiples_3 =[i*3 for i in range(1,21)]
print(multiples_3)

"""### Question 3

Use a list comprehension to create a list of names passed that only include those that scored at least 65.

"""

scores = {
             "Rick Ampofo": 70,
             "Morty Smith": 35,
             "Samuel Sarpong": 82,
             "Jerry Rawlings": 23,
             "Bethilda Great": 98
          }



passed =[name for name,score in scores.items() if score >= 65] 
print(passed)

# solution
passed =[(name,score) for name,score in scores.items() if score >= 65] 
print(passed)

z = scores.items()

